from __main__ import qt, ctk

from MRIChangeDetectorStep import *


class RegistrationStep(MRIChangeDetectorStep):
  def __init__(self, stepid):
    self.initialize(stepid)
    self.setName( '2. Select registration method' )
    self.setDescription( 'Select the registration method to be used when aligning the baseline with the follow-up volume.' )
    
    self.__parent = super(RegistrationStep, self)

    # Transform generated by the registration to go from the follow-up to the baseline volume
    self.__followupTransform = None
    # Volume generated by the registration (follow-up volume registered to baseline volume)
    self.__followupRegisteredVolume = None


  def createUserInterface(self):
    '''
    The interface allows choosing a registration method and applying it on the already chosen volumes.
    TODO: Alternatively the user can choose an already registered volume.
    '''

    self.__layout = self.__parent.createUserInterface()

    self.__registrationMethodLabel = qt.QLabel( 'Registration method:' )
    self.__registrationSelector = slicer.qMRMLNodeComboBox()
    self.__registrationSelector.toolTip = "Choose the preferred registration method"
    self.__registrationSelector.nodeTypes = ['vtkMRMLAnnotationTextNode']
    self.__registrationSelector.setMRMLScene(slicer.mrmlScene)
    self.__registrationSelector.addEnabled = 0

    # Create the possible registration method labels
    methods = ['General Registration (BRAINS)', 'Demon Registration (BRAINS)', 'BSpline deformable registration']

    #for m in methods:
    #  label = slicer.mrmlScene.CreateNodeByClass('vtkMRMLAnnotationTextNode')
    #  label.SetTextLabel(m)

    self.__label_BRAINS = slicer.mrmlScene.CreateNodeByClass('vtkMRMLAnnotationTextNode')
    self.__label_BRAINS.SetTextLabel(methods[0])
    self.__label_BRAINS.SetScene(slicer.mrmlScene)
    self.__label_BRAINS.SetVisible(True)
    self.__label_BRAINS.AddToSceneOn()

    label_demon = slicer.mrmlScene.CreateNodeByClass('vtkMRMLAnnotationTextNode')
    label_demon.SetTextLabel(methods[1])
    
    
    # Registration button
    self.__registrationButton = qt.QPushButton("Run registration")
    self.__registrationButton.toolTip = "Register the volumes."
    self.__registrationStatus = qt.QLabel('Registration Status: N/A')

    
    self.__layout.addRow(self.__registrationMethodLabel, self.__registrationSelector)
    self.__layout.addRow(self.__registrationButton)
    self.__layout.addRow("", qt.QWidget()) # empty row
    self.__layout.addRow(self.__registrationStatus)
    self.__registrationButton.connect('clicked()', self.onRegistrationRequest)


  def onEntry(self, comingFrom, transitionType):
    super(RegistrationStep, self).onEntry(comingFrom, transitionType)
    
    self.updateWidgetFromParameters(self.parameterNode())
    pNode = self.parameterNode()
    pNode.SetParameter('currentStep', self.stepid)


  def onExit(self, goingTo, transitionType):
    if goingTo.id() != 'Quantification':
      return

    # Nothing more because we already saved the volumes in pNode during validation
    super(SelectVolumesStep, self).onExit(goingTo, transitionType)

  
  def updateWidgetFromParameters(self, parameterNode):
    '''
    Update the widget according to the parameters selected by the user
    '''
    registrationMethodID = parameterNode.GetParameter('registrationMethodLabel')
    if registrationMethodID != None:
      self.__registrationSelector.setCurrentNode(slicer.mrmlScene.GetNodeByID(registrationMethodID))

      
  def validate(self, desiredBranchId):
    '''
    Must define it since we inherit from ctk.ctkWorkflowWidgetStep
    Check if the registration method has been chosen.
    '''
    self.__parent.validate(desiredBranchId)

    # Check that the selector is not empty
    method = self.__registrationSelector.currentNode()

    if method != None:
      pNode = self.parameterNode()
      pNode.SetParameter('registrationMethodLabel', method.GetTextLabel()) # TODO works?
      self.__parent.validationSucceeded(desiredBranchId)
    else:
      self.__parent.validationFailed(desiredBranchId, 'Error','Please select a registration method!')


  def onRegistrationRequest(self):
    pNode = self.parameterNode()
    baselineVolumeID = pNode.GetParameter('baselineVolumeID')
    followupVolumeID = pNode.GetParameter('followupVolumeID')
    methodLabel = pNode.GetParameter('registrationMethodLabel')

    # Create and add the new nodes to be filled during this step
    self.__followupTransform = slicer.mrmlScene.CreateNodeByClass('vtkMRMLLinearTransformNode')
    slicer.mrmlScene.AddNode(self.__followupTransform)
    self.__followupRegisteredVolume = slicer.mrmlScene.CreateNodeByClass('vtkMRMLScalarVolumeNode')
    slicer.mrmlScene.AddNode(self.__followupRegisteredVolume)

    parameters = {}
    registrationCLI = None
    
    # Choose the right registration method according to 'methodLabel' and fill its parameters
    parameters["linearTransform"] = self.__followupTransform.GetID()
    parameters["outputVolume"] = self.__followupRegisteredVolume.GetID()

    
    if methodLabel == 'BRAINSFit':
      registrationCLI = slicer.modules.brainsfit
      parameters["fixedVolume"] = baselineVolumeID
      parameters["movingVolume"] = followupVolumeID
      parameters["initializeTransformMode"] = "useCenterOfHeadAlign"
      parameters["useRigid"] = True
      parameters["useScaleVersor3D"] = True
      parameters["useScaleSkewVersor3D"] = True
      parameters["useAffine"] = True
    # TODO: Add more methods
    else: # Default to BRAINSFit
      registrationCLI = slicer.modules.brainsfit
      parameters["fixedVolume"] = baselineVolumeID
      parameters["movingVolume"] = followupVolumeID
      parameters["initializeTransformMode"] = "useCenterOfHeadAlign"
      parameters["useRigid"] = True
      parameters["useScaleVersor3D"] = True
      parameters["useScaleSkewVersor3D"] = True
      parameters["useAffine"] = True

    # Call the CLI
    self.__cliNode = None
    self.__cliNode = slicer.cli.run(registrationCLI, self.__cliNode, parameters)

    self.__cliObserverTag = self.__cliNode.AddObserver('ModifiedEvent', self.processRegistrationCompletion)
    self.__registrationStatus.setText('Wait ...')
    self.__registrationButton.setEnabled(0)


  def processRegistrationCompletion(self, node, event):
    status = node.GetStatusString()
    self.__registrationStatus.setText('Registration Status: '+status)
    if status == 'Completed':
      self.__registrationButton.setEnabled(1)
  
      pNode = self.parameterNode()
      # Apply the generated transform on the follow-up node. TODO: Do I really want this?
      followupNode = slicer.mrmlScene.GetNodeByID(pNode.GetParameter('followupVolumeID'))
      followupNode.SetAndObserveTransformNodeID(self.__followupTransform.GetID())
      
      setBgFgVolumes(pNode.GetParameter('baselineVolumeID'),pNode.GetParameter('followupVolumeID'))

      # Save both results in the parameterNode. TODO: I am probably repeating myself by saving the transform and also the new volume
      pNode.SetParameter('followupTransformID', self.__followupTransform.GetID())
      pNode.SetParameter('followupRegisteredVolumeID', self.__followupRegisteredVolume.GetID())


  def setBgFgVolumes(bg, fg):
    appLogic = slicer.app.applicationLogic()
    selectionNode = appLogic.GetSelectionNode()
    selectionNode.SetReferenceActiveVolumeID(bg)
    selectionNode.SetReferenceSecondaryVolumeID(fg)
    appLogic.PropagateVolumeSelection()